<!DOCTYPE section [
<!ENTITY % tnt SYSTEM "../tnt.ent">
%tnt;
]>
<section xmlns="http://docbook.org/ns/docbook" version="5.0"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xml:id="stored-procedures">
  <title>Writing stored procedures in Lua</title>
<blockquote>
    <para>
        <link xlink:href="http://www.lua.org">Lua</link>
        is a light-weight, multi-paradigm, embeddable language.
        Stored procedures in Lua can be used to implement
        data manipulation patterns or data structures. A
        server-side procedure written in Lua can select and modify
        data, access configuration and perform administrative
        tasks. It is possible to dynamically define, invoke,
        alter and drop Lua procedures.

    </para>
    <para>
        Tarantool uses <link
        xlink:href="http://www.luajit.org">LuaJIT</link>
        just-in-time Lua compiler and virtual machine.
        Apart from increased performance, this provides such
        features as <link
        xlink:href="http://bitop.luajit.org/">bitwise
        operations</link> and <link xlink:href="#tonumber64">64-bit integer arithmetics.</link>
    </para>
</blockquote>
<para>
    Procedures can be invoked from the administrative
    console and using the binary protocol, for example:
<programlisting><computeroutput>localhost> lua function f1() return 'hello' end
---
...
localhost> call f1()
Found 1 tuple:
['hello']
</computeroutput>
</programlisting>
    In the language of the administrative console
    <olink targetptr="lua-command" /> evaluates an arbitrary
    Lua chunk. CALL is the SQL standard statement used
    to invoke the CALL command of the binary
    protocol.
    In the example above, a Lua procedure is first defined
    using the text protocol of the administrative port,
    and then invoked using the Tarantool client-side SQL
    parser plus the binary protocol on the <olink targetptr="primary_port" />.
    Since it's possible to execute any Lua chunk in the
    administrative console, the newly created <code
    language="Pascal">function f1()</code>
    can be called there too:
<programlisting><computeroutput>localhost> lua f1()
---
 - hello
...
localhost> lua 1+2
---
 - 3
...
localhost> lua "hello".." world"
---
 - hello world
...
</computeroutput></programlisting>
  </para>
  <para>
    Lua procedures could also be called at the time of initialization
    using a dedicated <emphasis xml:id="init.lua" xreflabel="init.lua">init.lua</emphasis> script,
    located in <olink targetptr="work_dir" />.

    An example of such a script is given below:
    <programlisting>
    <![CDATA[
-- Importing expirationd module
dofile("expirationd.lua")

function is_expired(args, tuple)
   if tuple == nil then
       return true
   end

   if #tuple <= args.field_no then
       return true
   end

   field = tuple[args.field_no]
   if field == nil or #field ~= 4 then
       return true
   end

   local current_time = os.time()
   local tuple_ts = box.unpack("i", field)
   return current_time >= tuple_ts + args.ttl
end
function purge(args, tuple)
    box.space[0]:delete(tuple[0])
end

-- Run task
expirationd.run_task("exprd space 0", 0, is_expired, purge,
                    { field_no = 1, ttl = 30 * 60 })
]]>
    </programlisting>
  </para>

  <para>
    There is a single global instance of the Lua interpreter, which is
    shared across all connections. Anything prefixed with
    <code>lua </code> on the administrative console is sent
    directly to this interpreter. Any change of the interpreter
    state is immediately available to all client connections.
  </para>
  <para>
    Each connection, however, is using its own Lua
    <emphasis>coroutine</emphasis> &mdash; a mechanism akin to
    Tarantool <emphasis>fibers</emphasis>. A coroutine has an
    own execution stack and a Lua <emphasis>closure</emphasis>
    &mdash; set of local variables and definitions.
  </para>
  <para>
    The interpreter environment is not restricted when
     <olink targetptr="init.lua"/> is loaded. But before the
     server starts accepting requests, the standard Lua APIs, such
     as for file I/O, process control and module management are
     unset, to avoid possible trivial security attacks, and
     Tarantool-specific libraries are loaded.
  </para>
  <para>
    In the binary protocol, it's only possible to <emphasis
    role="strong">invoke</emphasis> existing
    procedures, but not <emphasis role="strong">define</emphasis>
    or <emphasis role="strong">alter</emphasis> them.
    CALL request packet contains CALL command code (22), the name
    of a procedure to be called, and a tuple for procedure
    arguments. Currently, Tarantool tuples are type-agnostic,
    thus each field of the tuple is passed into the procedure
    as an argument of type <quote>string</quote>. For example:
<programlisting><computeroutput>kostja@atlas:~$ cat arg.lua
function f1(a)
    local s = a
    if type(a) == 'string' then
        s = ''
        for i=1, #a, 1 do
            s = s..string.format('0x%x ', string.byte(a, i))
        end
    end
    return type(a), s
end
kostja@atlas:~$ tarantool
localhost> lua dofile('arg.lua')
---
...
localhost> lua f1('1234')
---
 - string
 - 0x31 0x32 0x33 0x34
...
localhost> call f1('1234')
Call OK, 2 rows affected
['string']
['0x31 0x32 0x33 0x34 ']
localhost> lua f1(1234)
---
 - number
 - 1234
...
localhost> call f1(1234)
Call OK, 2 rows affected
['string']
['0xd2 0x4 0x0 0x0 ']</computeroutput></programlisting>
    In the above example, the way the procedure receives its
    argument is identical in two protocols, when the argument is a
    string. A numeric field, however, when submitted via the
    binary protocol, is seen by the procedure as 
    a 4-byte blob, not as a Lua <quote>number</quote> type.
    </para>
    <para>In addition to conventional method invocation,
    Lua provides object-oriented syntax. Access to the latter is
    available on the administrative console only:
<programlisting><computeroutput>localhost> lua box.space[0]:truncate()
---
...
localhost> call box.space[0]:truncate()
error: 1:15 expected '('
</computeroutput></programlisting>
  </para>
  <para>
    Every value, returned from a stored function by means of
    <code>return</code> clause, is converted to a Tarantool/Box tuple.
    Tuples are returned as such, in binary form; a Lua scalar, such as
    a string or an integer, is converted to a tuple with only
    one field. When the returned value is a <emphasis>Lua
    table</emphasis>, the resulting tuple contains only table
    values, but not keys.
  </para>
  <para>
    When a function in Lua terminates with an error, the error
    is sent to the client as <olink targetptr="ER_PROC_LUA" />
    return code, with the original error message preserved.
    Similarly, an error which has occurred inside Tarantool (observed on the
    client as an error code), when happens during execution of a
    Lua procedure, produces a genuine Lua error:
<programlisting><computeroutput>localhost> lua function f1() error("oops") end
---
...
localhost> call f1()
Call ERROR, Lua error: [string "function f1() error("oops") end"]:1: oops (ER_PROC_LUA)
localhost> call box.insert('99', 1, 'test')
Call ERROR, Space 99 is disabled (ER_SPACE_DISABLED)
localhost> lua pcall(box.insert, 99, 1, 'test')
---
 - false
 - Space 99 is disabled
...
</computeroutput></programlisting>
  </para>
  <para>
    It's possible not only to invoke trivial Lua code, but call
    into Tarantool/Box storage functionality, using
    <code>box</code>
    Lua library. The contents of the library can be
    inspected at runtime:
<programlisting><computeroutput>localhost> lua for k, v in pairs(box) do print(k, ": ", type(v)) end
---
fiber: table
space: table
cfg: table
on_reload_configuration: function
update: function
process: function
delete: function
insert: function
select: function
index: table
unpack: function
replace: function
select_range: function
pack: function
...</computeroutput></programlisting>
    As is shown in the listing, <code>box</code> package ships:
    <itemizedlist>
        <listitem><para>
            high-level functions, such as
            <code>process(), update(), select(), select_range(), insert(),
                replace(), delete()</code>, to manipulate
                tuples and access spaces from Lua.
        </para></listitem>
        <listitem><para>
            libraries, such as <code>cfg, space, fiber, index, tuple</code>,
            to access server configuration, create, resume and
            interrupt fibers, inspect contents of spaces, indexes
            and tuples.
        </para></listitem>
    </itemizedlist>
  </para>

<variablelist>
    <title>Global Lua names added by Tarantool</title>
    <varlistentry>
        <term xml:id="tonumber64" xreflabel="tonumber64"> <emphasis role="lua">tonumber64(value)</emphasis></term>
        <listitem>
            <para>Convert a given string or a Lua number to a
            64-bit integer. The returned value supports all
            arithmetic operations, but uses
            64-bit integer arithmetics, rather than floating-point,
            arithmetics as in the built-in number type.
                <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
localhost> lua tonumber64('123456789'), tonumber64(123456789)
---
 - 123456789
 - 123456789
...
localhost> lua i=tonumber64(1)
---
...
localhost> lua type(i), type(i*2),  type(i/2), i, i*2, i/2
---
 - cdata
 - cdata
 - cdata
 - 1
 - 2
 - 0
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>
</variablelist>

<section>
    <title>Package <code>box</code></title>
<variablelist xml:id="box" xreflabel="box">
    <varlistentry>
        <term>
            <emphasis role="lua">box.process(op, request)</emphasis>
        </term>
        <listitem>
            <para>
                Process a request passed in as a binary string.
                This is an entry point into the server request
                processor. It can be used to insert, update,
                select and delete tuples from within a Lua procedure.
            </para>
            <para>
                This is a low-level API, and it expects
                all arguments to be packed in accordance
                with the binary protocol (iproto
                header excluded). Normally, there is no need
                to use <code>box.process()</code> directly:
                <code>box.select(), box.update()</code>
                and other convenience wrappers
                invoke <code>box.process()</code> with
                correctly packed arguments.
                <bridgehead renderas="sect4">Parameters</bridgehead>
                <simplelist>
                    <member><code>op</code> &mdash; number, any
                    Tarantool/Box command code, except 22 (CALL). See
                    <link xlink:href="https://github.com/mailru/tarantool/blob/master/doc/box-protocol.txt">
                    <filename>doc/box-protocol.txt</filename></link>.
                    </member>
                    <member><code>request</code> &mdash; command
                    arguments packed in binary format.</member>
                </simplelist>
                <bridgehead renderas="sect4">Returns</bridgehead>
                This function returns zero or more tuples. In Lua, a
                tuple is represented by a
                <emphasis>userdata</emphasis> object of type
                <code xlink:href="#box.tuple">box.tuple</code>. If
                a Lua procedure is called from the administrative
                console, returned tuples are printed out in YAML
                format.  When called from the binary
                protocol, the binary format is used.
                <bridgehead renderas="sect4">Errors</bridgehead>
                Any server error produced by the executed
                command.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.select" xreflabel="box.select">
                box.select(space_no, index_no, ...)
            </emphasis>
        </term>
        <listitem>
            <para>
                Select a tuple in the given space. A
                wrapper around <code>box.process()</code>.
                <bridgehead renderas="sect4">Parameters</bridgehead>
                <simplelist>
                    <member><code>space_no</code> &mdash; space id,
                    </member>
                    <member><code>index_no</code> &mdash; index number in the
                        space,</member>
                    <member><code>...</code>&mdash; index key,
                    possibly compound.
                    </member>
                </simplelist>
                <bridgehead renderas="sect4">Returns</bridgehead>
                Returns zero or more tuples.
                <bridgehead renderas="sect4">Errors</bridgehead>
                Same as in <code>box.process()</code>. Any error
                results in a Lua exception.
                <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
localhost> call box.insert(0, 'test', 'my first tuple')
Call OK, 1 rows affected
['test', 'my first tuple']
localhost> call box.select(0, 0, 'test')
Call OK, 1 rows affected
['test', 'my first tuple']
localhost> lua box.insert(5, 'testtest', 'firstname', 'lastname')
---
 - 'testtest': {'firstname', 'lastname'}
...
localhost> lua box.select(5, 1, 'firstname', 'lastname')
---
 - 'testtest': {'firstname', 'lastname'}
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.insert(space_no, ...)</emphasis>
        </term>
        <listitem><simpara></simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.replace(space_no, ...)</emphasis>
        </term>
        <listitem>
            <para>
                Insert a tuple into a space. Tuple fields
                follow <code>space_no</code>. If a tuple with
                the same primary key already exists,
                <code>box.insert()</code> returns an error, while
                <code>box.replace()</code> replaces the existing
                tuple with a new one. These functions are
                wrappers around <code>box.process()</code>
                <bridgehead renderas="sect4">Returns</bridgehead>
                Returns the inserted tuple.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.update(space_no, key, format, ...)</emphasis>
        </term>
        <listitem>
            <para>
                Update a tuple identified by a primary
                <code>key</code>. If a key is multipart,
                it is passed in as a Lua table. Update arguments follow,
                described by <code>format</code>.
                The format and arguments are passed to
                <code>box.pack()</code> and the result is sent
                to <code>box.process()</code>.
                A correct <code>format</code> is a sequence of
                pairs: update operation, operation arguments. A
                single character of format describes either an
                operation which needs to take place or operation
                argument. A format specifier also works as a
                placeholder for the number of a field, which needs
                to be updated, or for an argument value.
                For example: 
                <simplelist>
                    <member><code>+p=p</code> &mdash; add a value
                    to one field and assign another,
                    </member>
                    <member><code>:p</code> &mdash; splice a
                    field: start at offset, cut length bytes, and add a
                    string.</member>
                    <member><code>#p</code> &mdash; delete a
                    field.</member>
                    <member><code>!p</code> &mdash; insert a field
                    (before the one specified).</member>
                </simplelist>
                Possible format specifiers are: <quote>+</quote>
                for addition, <quote>-</quote> for subtraction,
                <quote>&amp;</quote> for bitwise AND,
                <quote>|</quote> for bitwise OR, <quote>^</quote>
                for bitwise exclusive OR (XOR), <quote>:</quote>
                for string splice and <quote>p</quote> for
                operation argument.
                <bridgehead renderas="sect4">Returns</bridgehead>
                Returns the updated tuple.
                <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
localhost> lua box.insert(0, 0, 'hello world')
---
 - 0: {'hello world'}
...
localhost> lua box.update(0, 0, '+p', 1, 1) -- add value 1 to field #1
---
error: 'Illegal parameters, numeric operation on a field with length != 4'
...
localhost> lua box.update(0, 0, '=p', 1, 1) -- assign field #1 to value 1
---
 - 0: {1}
...
localhost> lua box.update(0, 0, '+p', 1, 1)
---
 - 0: {2}
...
localhost> lua box.update(0, 2, '!p', 1, 'Bienvenue tout le monde!')
---
 - 2: {'Bienvenue tout le monde!', 'Hello world!'}
...
localhost> lua box.update(0, 2, '#p', 2, 'Bienvenue tout le monde!')
---
 - 2: {'Bienvenue tout le monde!'}
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.delete(space_no, ...)</emphasis>
        </term>
        <listitem><para>
            Delete a tuple identified by a primary key.
            <bridgehead renderas="sect4">Returns</bridgehead>
            Returns the deleted tuple.
                <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
localhost> call box.delete(0, 'test')
Call OK, 1 rows affected
['test', 'my first tuple']
localhost> call box.delete(0, 'test')
Call OK, 0 rows affected
localhost> call box.delete(0, 'tes')
Call ERROR, Illegal parameters, key is not u32 (ER_ILLEGAL_PARAMS)
</programlisting>
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.select_range" xreflabel="box.select_range">
                box.select_range(space_no, index_no, limit, key, ...)
            </emphasis>
        </term>
        <listitem><para>
            Select a range of tuples, starting from offset
            specified by <code>key</code>. The key can be
            multipart.  Limit selection with at most
            <code>limit</code> tuples.  If no key is specified,
            start from the first key in the index.
        </para>
        <para>
            For TREE indexes, this returns tuples in sorted order.
            For HASH indexes, the order of tuples is unspecified, and
            can change significantly if data is inserted or deleted
            between two calls to <code>box.select_range()</code>.
            If <code>key</code> is <code>nil</code> or unspecified,
            the selection starts from the start of the index.
            This is a simple wrapper around <code xlink:href="#box.space.select_range">box.space[space_no]:select_range(index_no, ...)</code>.
        </para>
        <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>localhost> show configuration
---
...
  space[4].cardinality: "-1"
  space[4].estimated_rows: "0"
  space[4].index[0].type: "HASH"
  space[4].index[0].unique: "true"
  space[4].index[0].key_field[0].fieldno: "0"
  space[4].index[0].key_field[0].type: "STR"
  space[4].index[1].type: "TREE"
  space[4].index[1].unique: "false"
  space[4].index[1].key_field[0].fieldno: "1"
  space[4].index[1].key_field[0].type: "STR"
...
localhost> insert into t4 values ('0', '0')
Insert OK, 1 rows affected
localhost> insert into t4 values ('1', '1')
Insert OK, 1 rows affected
localhost> insert into t4 values ('2', '2')
Insert OK, 1 rows affected
localhost> insert into t4 values ('3', '3')
Insert OK, 1 rows affected
ocalhost> lua box.select_range(4, 0, 10)
---
 - '3': {'3'}
 - '0': {'0'}
 - '1': {'1'}
 - '2': {'2'}
...
localhost> lua box.select_range(4, 1, 10)
---
 - '0': {'0'}
 - '1': {'1'}
 - '2': {'2'}
 - '3': {'3'}
...
localhost> lua box.select_range(4, 1, 2)
---
 - '0': {'0'}
 - '1': {'1'}
...
localhost> lua box.select_range(4, 1, 2, '1')
---
 - '1': {'1'}
 - '2': {'2'}
...
</programlisting>
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.select_reverse_range" xreflabel="box.select_reverse_range">
                box.select_reverse_range(space_no, index_no, limit, key, ...)
            </emphasis>
        </term>
        <listitem><para>
            Select a reverse range of tuples, starting from the offset
            specified by <code>key</code>. The key can be
            multipart.
            Limit selection with at most <code>limit</code>
            tuples.
            If no key is specified, start from the last key in
            the index.
            </para>
            <para>
            For TREE indexes, this returns tuples in sorted order.
            Reverse iteration for HASH indexes is not supported.
            If <code>key</code> is <code>nil</code> or unspecified,
            the selection starts from the end of the index.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>localhost> show configuration
---
...
  space[4].cardinality: "-1"
  space[4].estimated_rows: "0"
  space[4].index[0].type: "HASH"
  space[4].index[0].unique: "true"
  space[4].index[0].key_field[0].fieldno: "0"
  space[4].index[0].key_field[0].type: "STR"
  space[4].index[1].type: "TREE"
  space[4].index[1].unique: "false"
  space[4].index[1].key_field[0].fieldno: "1"
  space[4].index[1].key_field[0].type: "STR"
...
localhost> insert into t4 values ('0', '0')
Insert OK, 1 rows affected
localhost> insert into t4 values ('1', '1')
Insert OK, 1 rows affected
localhost> insert into t4 values ('2', '2')
Insert OK, 1 rows affected
localhost> insert into t4 values ('3', '3')
Insert OK, 1 rows affected
localhost> lua box.select_reverse_range(4, 0, 10)
---
 error: 'Illegal parameters, hash iterator is forward only
...
localhost> lua box.select_reverse_range(4, 1, 10)
---
 - '3': {'3'}
 - '2': {'2'}
 - '1': {'1'}
 - '0': {'0'}
...
localhost> lua box.select_reverse_range(4, 1, 2)
---
 - '3': {'3'}
 - '2': {'2'}
...
localhost> lua box.select_reverse_range(4, 1, 2, '1')
---
 - '1': {'1'}
 - '0': {'0'}
...
</programlisting>
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.pack(format, ...)</emphasis></term>
        <listitem><para>
            To use Tarantool binary protocol primitives from Lua,
            it's necessary to convert Lua variables to binary
            format. This helper function is prototyped after Perl
            'pack'. It takes a format and a list of arguments, and
            returns a binary string with all arguments packed
            according to the format.
            <bridgehead renderas="sect4">Format specifiers</bridgehead>
            <simplelist>
                <member><code>b</code> &mdash; converts Lua
                variable to a 1-byte
                integer, and stores the integer in the resulting
                string
                </member>
                <member><code>s</code> &mdash; converts Lua
                variable to a 2-byte
                integer, and stores the integer in the resulting
                string, low byte first,
                </member>
                <member><code>i</code> &mdash; converts Lua
                variable to a 4-byte
                integer, and stores the integer in the resulting
                string, low byte first,
                </member>
                <member><code>l</code> &mdash; converts Lua
                variable to a 8-byte
                integer, and stores the integer in the resulting
                string, low byte first,
                </member>
                <member><code>w</code> &mdash; converts Lua
                variable to a BER-encoded
                integer, and stores the integer in the resulting
                string
                </member>
                <member><code>p</code> &mdash; stores the length
                of the argument as a 4-byte integer, low byte first,
                followed by the argument itself: a 4-byte integer, low
                byte first, for integers, or a binary blob for
                anything else,
                </member>
                <member><code>=, +, &amp;, |, ^, : </code>&mdash;
                stores the corresponding Tarantool UPDATE
                operation code: field assignment, addition,
                conjunction, disjunction, exclusive disjunction,
                splice (from Perl SPLICE function). Expects
                field number to update as an argument. These format
                specifiers only store the corresponding operation
                code and field number to update, but do not
                describe operation arguments.
                </member>
            </simplelist>
        <bridgehead renderas="sect4">Errors</bridgehead>
        Unknown format specifier.
        <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
localhost> lua box.insert(0, 0, 'hello world')
---
 - 0: {'hello world'}
...
localhost> lua box.update(0, 0, "=p", 1, 'bye world')
---
 - 0: {'bye world'}
...
localhost> lua box.update(0, 0, ":p", 1, box.pack('ppp', 0, 3, 'hello'))
---
 - 0: {'hello world'}
...
localhost> lua box.update(0, 0, "=p", 1, 4)
---
 - 0: {4}
...
localhost> lua box.update(0, 0, "+p", 1, 4)
---
 - 0: {8}
...
localhost> lua box.update(0, 0, "^p", 1, 4)
---
 - 0: {12}
...
</programlisting>
        </para></listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua">box.unpack(format, ...)</emphasis></term>
        <listitem><para>
            Counterpart to <code>box.pack()</code>. Only supports
            <code>'b'</code>, <code>'s'</code>, <code>'i'</code>, <code>'l'</code> format specifiers, and can be used
            to convert packed integers to Lua numbers.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>localhost> lua tuple=box.replace(2, 0)
---
...
localhost> lua string.len(tuple[0])
---
 - 4
...
localhost> lua box.unpack('i', tuple[0])
---
 - 0
...
</programlisting>
        </para></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.print(...)</emphasis>
        </term>
        <listitem><para>
Redefines Lua <code>print()</code> built-in to print either to the log file
(when Lua is used from the binary port) or back to the user (for the
administrative console).
</para><para>
When printing to the log file, INFO log level is used. When printing to
the administrative console, all output is sent directly
to the socket.
</para><para>
Note: the administrative console output must be YAML-compatible.
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.dostring(s, ...)</emphasis>
        </term>
        <listitem>
            <para>
                Evaluates an arbitrary chunk of lua code passed in
                <code>s</code>. If there is a compilation error,
                it's raised as a Lua error. In case of compilation
                success, all arguments which follow <code>s</code>
                are passed to the compiled chunk and the chunk is
                invoked.
            </para>
            <para>
                This function is mainly useful to define and run
                an arbitrary piece of Lua code, without having to
                introduce changes to the global Lua environment.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>lua box.dostring('abc')
---
error: '[string "abc"]:1: ''='' expected near ''&lt;eof&gt;'''
...
lua box.dostring('return 1')
---
 - 1
...
lua box.dostring('return ...', 'hello', 'world')
---
 - hello
 - world
...
lua box.dostring('local f = function(key) t=box.select(0, 0, key); if t ~= nil then return t[0] else return nil end end return f(...)', 0)
---
 - nil
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.uuid()</emphasis>
        </term>
        <listitem>
            <para>
                Generate 128-bit (16 bytes) unique id. The id
                is returned in binary form.
            </para>
            <para>
                Requires <emphasis>libuuid</emphasis> library to be
                installed. The library is loaded in runtime,
                and if the library is not available, this
                function returns an error.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.uuid_hex()</emphasis>
        </term>
        <listitem>
            <para>
                Generate hex-string of 128-bit (16 bytes) unique id.
                Return 32-bytes string.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>
                lua box.uuid_hex()
                ---
                 - a4f29fa0eb6d11e19f7737696d7fa8ff
                ...
            </programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.auto_increment(space_no, ...)</emphasis>
        </term>
        <listitem>
            <para>
                Insert values into space designated by space_no, using
                an auto-increment primary key. The space must have a
                NUM or NUM64 primary key index of type TREE.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>localhost> lua box.auto_increment(0, "I am a duplicate")
---
 - 1: {'I am a duplicate'}
...
localhost> lua box.auto_increment(0, "I am a duplicate")
---
 - 2: {'I am a duplicate'}
...
            </programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.counter.inc(space_no, key)</emphasis>
        </term>
        <listitem>
            <para>
                Increments a counter identified by the key. The key can be
                multi-part, but there must be an index covering
                all fields of the key. If there is no tuple
                identified by the given key, creates a new one
                with initial counter value set to 1.  Returns the
                new counter value back.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>localhost> lua box.counter.inc(0, 'top.mail.ru')
---
 - 1
...
localhost> lua box.counter.inc(0, 'top.mail.ru')
---
 - 2
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.counter.dec(space_no, key)</emphasis>
        </term>
        <listitem>
            <para>
                Decrements a counter identified by the given key. If
                the key is not found, is a no-op. When counter value
                drops to 0, the tuple is deleted.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>localhost> lua box.counter.dec(0, 'top.mail.ru')
---
 - 1
...
localhost> lua box.counter.dec(0, 'top.mail.ru')
---
 - 0
...</programlisting>
        </listitem>
    </varlistentry>
</variablelist>
</section>

<section>
    <title>Package <code>box.tuple</code></title>

<variablelist xml:id="box.tuple" xreflabel="box.tuple">
    <para>The package contains no functions, but stands for
    <code>box.tuple</code> userdata type. It is possible to access individual
    tuple fields using an index, select a range of fields, iterate
    over all fields in a tuple or convert a tuple to a Lua table.
    Tuples are immutable.</para>
    <varlistentry>
        <term><emphasis role="lua"> </emphasis></term>
        <listitem><para>
        <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
localhost> lua t=box.insert(0, 1, 'abc', 'cde', 'efg', 'ghq', 'qkl')
---
...
localhost> lua #t
---
 - 6
...
localhost> lua t[1], t[5]
---
 - abc
 - qkl
...
localhost> lua t[6]
---
error: 'Lua error: [string "return t[6]"]:1: box.tuple: index 6 is out of bounds (0..5)'
...
localhost> lua for k,v in t:pairs() do print(v) end
---

abc
cde
efg
ghq
qkl
...
localhost> lua t:unpack()
---
 - 
 - abc
 - cde
 - efg
 - ghq
 - qkl
...
localhost> lua t:slice(1, 2)
---
 - abc
...
localhost> lua t:slice(1, 3)
---
 - abc
 - cde
...
localhost> lua t:slice(1, -1)
---
 - abc
 - cde
 - efg
 - ghq
...
localhost> lua t:transform(1, 3)
---
 - 1: {'ghq', 'qkl'}
...
localhost> lua t:transform(0, 1, 'zyx')
---
 - 'zyx': {'abc', 'cde', 'efg', 'ghq', 'qkl'}
...
localhost> lua t:transform(-1, 1, 'zyx')
---
 - 1: {'abc', 'cde', 'efg', 'ghq', 'zyx'}
...
localhost> lua t=box.insert(0, 'abc', 'def', 'abc')
---
...
localhost> lua t:find('abc')
---
 - 0
...
localhost> lua t:findall('abc')
---
 - 0
 - 2
...
localhost> lua t:find(1, 'abc')
---
 - 2
...
</programlisting>

        </para></listitem>
    </varlistentry>
</variablelist>
</section>

<section>
    <title>Package <code>box.space</code></title>
<variablelist xml:id="box.space" xreflabel="box.space">
    <para>This package is a container for all
    configured spaces. A space object provides access to space
    attributes, such as id, whether or not a space is
    enabled, space cardinality, estimated number of rows. It also
    contains object-oriented versions of <code>box</code>
    functions. For example, instead of <code>box.insert(0, ...)</code>
    one can write <code>box.space[0]:insert(...)</code>.
    Package source code is available in file <filename
    xlink:href="https://github.com/mailru/tarantool/blob/master/src/box/box.lua">src/box/box.lua</filename></para>
    <para>A list of all <code>space</code> members follows.</para>
    <varlistentry>
        <term><emphasis role="lua">space.n</emphasis></term>
        <listitem><simpara>Ordinal space number, <code>box.space[i].n == i</code></simpara></listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">space.enabled</emphasis></term>
        <listitem><simpara>
            Whether or not this space is enabled in the
            configuration file.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space.cardinality</emphasis>
        </term>
        <listitem><simpara>
            A limit on tuple field count for tuples in this space.
            This limit can be set in the configuration file. Value 0
            stands for <quote>unlimited</quote>.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space.index[]</emphasis>
        </term>
        <listitem><simpara>
            A container for all defined indexes. An index is a Lua object
            of type <code xlink:href="#box.index">box.index</code> with
            methods to search tuples and iterate over them in predefined order.
        </simpara></listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">space:select(index_no, ...)</emphasis>
        </term>
        <listitem><simpara></simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.space.select_range" xreflabel="box.space[i].select_range()">
                space:select_range(index_no, limit, key)
            </emphasis>
        </term>
        <listitem>
            <simpara>
                Select a range of tuples, starting from offset specified by
                <code>key</code>. The key can be multipart.
                Limit selection with at most <code>limit</code> tuples.
                If no key is specified, start from the first key in the index.
            </simpara>
            <simpara>
                For TREE indexes, this returns tuples in sorted order.
                For other indexes, the order of tuples is unspecified, and
                can change significantly if data is inserted or deleted
                between two calls to <code>select_range()</code>.
                If <code>key</code> is <code>nil</code> or unspecified,
                the selection starts from the start of the index.
            </simpara>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua"
            xml:id="box.space.select_reverse_range"
            xreflabel="box.space.select_reverse_range">
            space:select_reverse_range(limit, key)</emphasis>
        </term>
        <listitem>
            <simpara>
                Select a reverse range of tuples, limited by
                <code>limit</code>, starting from <code>key</code>.
                The key can be multipart. TREE index returns tuples in descending
                order. Not supported by HASH indexes.
            </simpara>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:insert(...)</emphasis>
        </term>
        <listitem><simpara></simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:replace(...)</emphasis>
        </term>
        <listitem><simpara></simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:delete(key)</emphasis>
        </term>
        <listitem><simpara></simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:update(key, format, ...)</emphasis>
        </term>
        <listitem><simpara></simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:insert(...)</emphasis>
        </term>
        <listitem><simpara>
            Object-oriented forms of respective <code
            xlink:href="#box">box</code> methods.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:len()</emphasis>
        </term>
        <listitem><simpara>
            Returns number of tuples in the space.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:truncate()</emphasis>
        </term>
        <listitem><simpara>
            Deletes all tuples.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">space:pairs()</emphasis>
        </term>
        <listitem><simpara>
            A helper function to iterate over all space tuples,
            Lua style.
        </simpara>
                <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
localhost> lua for k,v in box.space[0]:pairs() do print(v) end
---
1: {'hello'}
2: {'my     '}
3: {'Lua    '}
4: {'world'}
...
</programlisting>
        </listitem>
    </varlistentry>
</variablelist>
</section>

<section>
    <title>Package <code >box.index</code></title>
<variablelist xml:id="box.index" xreflabel="box.index">
    <para>
        This package implements methods of type <code>box.index</code>.
        Indexes are contained in <code
        xlink:href="#box.space">box.space[i].index[]</code> array
        within each space object. They provide an API for
        ordered iteration over tuples.
    </para>
    <varlistentry>
        <term><emphasis role="lua">index.unique</emphasis></term>
        <listitem><simpara>
            Boolean, true if the index is unique.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">index.type</emphasis>
        </term>
        <listitem><simpara>
            A string for index type, either 'TREE' or 'HASH'.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">index.key_field[]</emphasis>
        </term>
        <listitem><simpara>
            An array describing index key fields.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">index.idx</emphasis>
        </term>
        <listitem><simpara>
            The underlying userdata which does all the magic.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
             <emphasis role="lua" xml:id="box.index.iterator" xreflabel="box.index.iterator">
            index:iterator(type, ...)</emphasis>
        </term>
        <listitem>
            <simpara>
                This method provides iteration support within an
                index. Parameter <code>type</code> is used to
                identify the semantics of iteration. Different
                index types support different iterators. The
                remaining arguments of the function are varying
                and depend on the iteration type. For example,
                TREE index maintains a strict order of keys and
                can return all tuples in ascending or descending
                order, starting from the specified key. A HASH
                index, however, doesn't support ordering.
            </simpara>
            <para>
                <bridgehead renderas="sect4">Parameters</bridgehead>
                <simplelist>
                        <member><code>type</code> &mdash; iteration strategy as defined in a table below.</member>
                </simplelist>

                <bridgehead renderas="sect4">Returns</bridgehead>
                    This method returns an iterator closure, i.e.
                    a <code>function</code> which can be used to
                    get the next value on each invocation.
                <bridgehead renderas="sect4">Errors</bridgehead>
                    Selected iteration type is not supported in
                    the subject index type or supplied parameters
                    do not match iteration type.
            </para>

            <xi:include href="iterator-types.xml"/>

            <para>
                <bridgehead renderas="sect4">Examples</bridgehead>
<programlisting>
localhost> show configuration
---
...
  space[0].enabled: "true"
  space[0].index[0].type: "HASH"
  space[0].index[0].unique: "true"
  space[0].index[0].key_field[0].fieldno: "0"
  space[0].index[0].key_field[0].type: "NUM"
  space[0].index[1].type: "TREE"
  space[0].index[1].unique: "false"
  space[0].index[1].key_field[0].fieldno: "1"
  space[0].index[1].key_field[0].type: "NUM"
  space[0].index[1].key_field[1].fieldno: "2"
  space[0].index[1].key_field[1].type: "NUM"
...
localhost> INSERT INTO t0 VALUES (1, 1, 0)
Insert OK, 1 rows affected
localhost> INSERT INTO t0 VALUES (2, 1, 1)
Insert OK, 1 rows affected
localhost> INSERT INTO t0 VALUES (3, 1, 2)
Insert OK, 1 rows affected
localhost> INSERT INTO t0 VALUES (4, 2, 0)
Insert OK, 1 rows affected
localhost> INSERT INTO t0 VALUES (5, 2, 1)
Insert OK, 1 rows affected
localhost> INSERT INTO t0 VALUES (6, 2, 2)
Insert OK, 1 rows affected
localhost> lua it = box.space[0].index[1]:iterator(box.index.EQ, 1); print(it(), " ", it(), " ", it());
---
1: {1, 0} 2: {1, 1} 3: {1, 2}
...
localhost> lua it = box.space[0].index[1]:iterator(box.index.EQ, 1, 2); print(it(), " ", it(), " ", it());
---
3: {1, 2} nil nil
...
localhost> lua i = box.space[0].index[1]:iterator(box.index.GE, 2, 1);  print(it(), " ", it(), " ", it());
---
5: {2, 1} 6: {2, 2} nil
...
localhost> lua for v in box.space[0].index[1]:iterator(box.index.ALL) do print(v) end
---
1: {1, 0}
2: {1, 1}
3: {1, 2}
4: {2, 0}
5: {2, 1}
6: {2, 2}
...
localhost> lua i = box.space[0].index[0]:iterator(box.index.LT, 1);
---
error: 'Iterator type is not supported'
</programlisting>
            </para>
        </listitem>
    </varlistentry>


    <varlistentry>
        <term>
            <emphasis role="lua">index:min()</emphasis>
        </term>
        <listitem><simpara>
            The smallest value in the index. Available only for
            indexes of type 'TREE'.
        </simpara>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">index:max()</emphasis>
        </term>
        <listitem><simpara>
            The biggest value in the index. Available only for
            indexes of type 'TREE'.
        </simpara>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">index:count()</emphasis>
        </term>
        <listitem><simpara>
           Iterate over an index, count the number of tuples which equal the
           provided search criteria. The argument can either point to a
           tuple, a key, or one or more key parts. Returns the number of matched
           tuples.
        </simpara>
        </listitem>
    </varlistentry>

</variablelist>
</section>

<section>
    <title>Package <code>box.fiber</code></title>
<variablelist xml:id="box.fiber">
    <para>Functions in this package allow you to create, run and
    manage existing <emphasis>fibers</emphasis>.
    </para>
    <para>
A fiber is an independent execution thread implemented
using a mechanism of cooperative multitasking.

A fiber has three possible states: running, suspended or dead.
When a fiber is created with <code>box.fiber.create()</code>,
it is suspended.
When a fiber is started with <code>box.fiber.resume()</code>, it is running.
When a fiber's control is yielded back to the caller with
<code>box.fiber.yield()</code>, it is suspended.
When a fiber ends (due to <code>return</code> or by reaching the
end of the fiber function), it is dead.
    </para>
    <para>
A fiber can also be attached or detached.
An attached fiber is a child of the creator,
and is running only if the creator has called
<code>box.fiber.resume()</code>. A detached fiber is a child of
Tarantool internal <quote>sched</quote> fiber, and gets
scheduled only if there is a libev event associated
with it.
    </para>
    <para>
To detach, a running fiber must invoke <code>box.fiber.detach()</code>.
A detached fiber loses connection with its parent forever.
    </para>
    <para>
All fibers are part of the fiber registry, <code>box.fiber</code>.
This registry can be searched (<code>box.fiber.find()</code>)
either by fiber id (fid), which is numeric, or by fiber name,
which is a string. If there is more than one fiber with the given
name, the first fiber that matches is returned.
    </para>
    <para>
Once fiber function is done or calls <code>return</code>,
the fiber is considered dead. Its carcass is put into
a fiber pool, and can be reused when another fiber is
created.
    </para>
    <para>
A runaway fiber can be stopped with <code>box.fiber.cancel()</code>.
<code>box.fiber.cancel()</code>, however, is advisory &mdash; it works
only if the runaway fiber is calling <code>box.fiber.testcancel()</code>
once in a while. Most <code>box.*</code> hooks, such as <code>box.delete()</code>
or <code>box.update()</code>, are calling <code>box.fiber.testcancel()</code>.
<code>box.select()</code> doesn't.
    </para>
    <para>
In practice, a runaway fiber can only become unresponsive
if it does a lot of computations and doesn't check
whether it's been canceled. In addition
to the advisory cancellation, configuration parameter <code>lua_timeout</code>
can be used to cancel runaway Lua procedures.
    </para>
    <para>
The other potential problem comes from detached
fibers which never get scheduled, because they are not subscribed
to any events, or because no relevant events occur. Such morphing fibers
can be killed with <code>box.fiber.cancel()</code> at any time,
since <code>box.fiber.cancel()</code>
sends an asynchronous wakeup event to the fiber,
and <code>box.fiber.testcancel()</code> is checked whenever such an event occurs.
    </para>
    <para>Like all Lua objects, dead fibers are
    garbage collected: the garbage collector frees pool allocator
    memory owned by the fiber, resets all fiber data, and returns
    the fiber to the fiber pool.</para>
    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.id(fiber) </emphasis>
        </term>
        <listitem><simpara>Return a numeric id of the fiber.</simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.self() </emphasis>
        </term>
        <listitem><simpara>Return <code>box.fiber</code> userdata
        object for the currently scheduled fiber.</simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.find(id) </emphasis>
        </term>
        <listitem><simpara>Locate a fiber userdata object by id.</simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.create(function) </emphasis>
        </term>
        <listitem><simpara>
            Create a fiber for <code>function</code>.
        </simpara>
        <bridgehead renderas="sect4">Errors</bridgehead>
        <simpara>Can hit a recursion limit.</simpara>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.resume(fiber, ...) </emphasis>
        </term>
        <listitem><simpara>Resume a created
        or suspended fiber.</simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.yield(...) </emphasis>
        </term>
        <listitem><para>
        Yield control to the calling fiber, if the fiber
        is attached, or to sched otherwise.
        </para>
        <para>
        If the fiber is attached, whatever arguments are passed
        to this call, are passed on to the calling fiber.
        If the fiber is detached, <code>box.fiber.yield()</code>
        returns back everything passed into it.
        </para></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.detach()</emphasis>
        </term>
        <listitem><simpara>
        Detach the current fiber. This is a cancellation point. This is a yield point.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.sleep(time)</emphasis>
        </term>
        <listitem><simpara>
    Yield to the sched fiber and sleep <code>time</code> seconds.
    Only the current fiber can be made to sleep.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.cancel(fiber)</emphasis>
        </term>
        <listitem><simpara>
        Cancel a <code>fiber</code>.
        Running and suspended fibers can be canceled.
        Returns an error if the subject fiber does not permit cancel.
        </simpara></listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.fiber.testcancel()</emphasis>
        </term>
        <listitem><simpara>
            Check if the current fiber has been canceled and
            throw an exception if this is the case.
        </simpara></listitem>
    </varlistentry>
</variablelist>
</section>

<!--   end of lib -->

<section>
    <title>Package <code>box.ipc</code> &mdash; inter procedure communication</title>
<variablelist xml:id="box.ipc">
    <simpara>
    </simpara>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel(capacity)</emphasis></term>
        <listitem>
            <simpara>
                Create a new communication channel with
                predefined capacity. The channel can be used
                to synchronously exchange messages between
                stored procedures. The channel is garbage
                collected when no one is using it as any other
                Lua object. Channels can be worked with using
                functional or object-oriented syntax.
                For example, the following two lines are equivalent:

            </simpara>
<programlisting>
    channel:put(message)
    box.ipc.channel.put(channel, message)
</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel.put(channel, message, timeout)</emphasis></term>
        <listitem>
            <simpara>
                Send a message using a channel. If the channel is full,
                <emphasis role="lua">box.ipc.channel.put()</emphasis>
                blocks until there is a free slot in the channel.
                If <emphasis role="lua">timeout</emphasis> is provided,
                and the channel doesn't become empty in the duration
                of the timeout,
                <emphasis role="lua">box.ipc.channel.put()</emphasis>
                returns false. Otherwise it returns true.
            </simpara>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel.get(channel, timeout)</emphasis></term>
        <listitem>
            <simpara>
                Fetch a message from a channel. If the channel is empty,
                <emphasis role="lua">box.ipc.channel.get()</emphasis>
                blocks until there is a message.
                If <emphasis role="lua">timeout</emphasis> is provided,
                and the channel there are no new messages in the duration
                of the timeout,
                <emphasis role="lua">box.ipc.channel.get()</emphasis>
                returns error.
            </simpara>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel.broadcast(channel, message, timeout)</emphasis></term>
        <listitem>
            <simpara>
                If the channel is empty, is equivalent to
                <emphasis role="lua">box.ipc.channel.put()</emphasis>.
                Otherwise sends the message to all readers of the
                channel.
            </simpara>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel.is_empty(channel)</emphasis></term>
        <listitem>
            <simpara>
                Check if the channel is empty (has no messages).
            </simpara>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel.is_full(channel)</emphasis></term>
        <listitem>
            <simpara>
                Check if the channel is full (has no room for a new message).
            </simpara>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel.has_readers(channel)</emphasis></term>
        <listitem>
            <simpara>
                Check if the channel is empty and has readers waiting
                for a message.
            </simpara>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">box.ipc.channel.has_writers(channel)</emphasis></term>
        <listitem>
            <simpara>
                Check if the channel is full and has writers waiting
                for empty room.
            </simpara>
            <bridgehead renderas="sect4">Example</bridgehead><programlisting>
local channel = box.ipc.channel(10)
function consumer_fiber()
    while true do
        local task = channel:get()
        ...
    end
end

function consumer2_fiber()
    while true do
        local task = channel:get(10)        -- 10 seconds
        if task ~= nil then
            ...
        else
            print("timeout!")
        end
    end
end

function producer_fiber()
    while true do
        task = box.select(...)
        ...
        if channel:is_empty() then
            # channel is empty
        end

        if channel:is_full() then
            # channel is full
        end

        ...
        if channel:has_readers() then
            # there are some fibers that wait data
        end
        ...

        if channel:has_writers() then
            # there are some fibers that wait readers
        end
        channel:put(task)
    end
end

function producer2_fiber()
    while true do
        task = box.select(...)

        if channel:put(task, 10) then       -- 10 seconds
            ...
        else
            print("timeout!")
        end
    end
end
</programlisting>
        </listitem>
    </varlistentry>
</variablelist>
</section>

<section>
    <title>Packages <code>box.cfg</code>,
    <code>box.info</code>, <code>box.slab</code> and
    <code>box.stat</code>: server introspection</title>

<variablelist>
    <title>Package <code xml:id="box.cfg">box.cfg</code></title>
    <para>This package provides read-only access to
    all server configuration parameters.</para>
    <varlistentry>
        <term><emphasis role="lua">box.cfg</emphasis></term>
        <listitem><bridgehead renderas="sect4">Example</bridgehead><programlisting>
localhost> lua for k, v in pairs(box.cfg) do print(k, " = ", v) end
---
io_collect_interval = 0
pid_file = box.pid
panic_on_wal_error = false
slab_alloc_factor = 2
slab_alloc_minimal = 64
admin_port = 33015
logger = cat - >> tarantool.log
...
</programlisting></listitem>
    </varlistentry>
</variablelist>

<variablelist>
    <title>Package <code>box.info</code></title>
    <para>
        This package provides access to information about
        server variables: pid, uptime, version and such.
        Its contents is identical to output of <olink
        targetptr="show-info"/>.
    </para>
    <varlistentry>
        <term>
            <emphasis role="lua">box.info()</emphasis>
        </term>
        <listitem>
            <simpara>
            Since contents of box.info is dynamic, it's
            not possible to iterate over keys with Lua <emphasis>pairs()</emphasis>
            function. For this purpose, <emphasis>box.info()</emphasis> builds
            and returns a Lua table with all keys and values
            provided in the package.
            </simpara>

       <bridgehead renderas="sect4">Example</bridgehead><programlisting>
localhost> lua for k,v in pairs(box.info()) do print(k, ": ", v) end
---
version: 1.4.7-92-g4ba95ca
status: primary
pid: 1747
lsn: 1712
recovery_last_update: 1306964594.980
recovery_lag: 0.000
uptime: 39
build: table: 0x419cb880
logger_pid: 1748
config: /home/unera/work/tarantool/test/box/tarantool_good.cfg
...
</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.info.status, box.info.pid, box.info.lsn, ...</emphasis>
        </term>
        <listitem>
       <bridgehead renderas="sect4">Example</bridgehead><programlisting>
localhost> lua box.info.pid
---
 - 1747
...
localhost> lua box.info.logger_pid
---
 - 1748
...
localhost> lua box.info.version
---
 - 1.4.7-92-g4ba95ca
...
localhost> lua box.info.config
---
 - /home/unera/work/tarantool/test/box/tarantool_good.cfg
...
localhost> lua box.info.uptime
---
 - 3672
...
localhost> lua box.info.lsn
---
 - 1712
...
localhost> lua box.info.status
---
 - primary
...
localhost> lua box.info.recovery_lag
---
 - 0.000
...
localhost> lua box.info.recovery_last_update
---
 - 1306964594.980
...
localhost> lua box.info.snapshot_pid
---
 - 0
...
localhost> lua for k, v in pairs(box.info.build) do print(k .. ': ', v) end
---
flags:  -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -DCORO_ASM -fno-omit-frame-pointer -fno-stack-protector -fexceptions -funwind-tables -fgnu89-inline -pthread  -Wno-sign-compare -Wno-strict-aliasing -std=gnu99 -Wall -Wextra -Werror
target: Linux-x86_64-Debug
compiler: /usr/bin/gcc
options: cmake . -DCMAKE_INSTALL_PREFIX=/usr/local -DENABLE_STATIC=OFF -DENABLE_GCOV=OFF -DENABLE_TRACE=ON -DENABLE_BACKTRACE=ON -DENABLE_CLIENT=OFF
...
</programlisting>
        </listitem>
    </varlistentry>
</variablelist>
<variablelist>
    <title>Package <code>box.slab</code></title>
    <para>This package provides access to slab allocator statistics.</para>
    <varlistentry>
        <term><emphasis role="lua">box.slab</emphasis></term>
        <listitem><bridgehead renderas="sect4">Example</bridgehead><programlisting>
localhost> lua box.slab.arena_used
---
 - 4194304
...
localhost> lua box.slab.arena_size
---
 - 104857600
...
localhost> lua for k, v in pairs(box.slab.slabs) do print(k) end
---
64
128
...
localhost> lua for k, v in pairs(box.slab.slabs[64]) do print(k, ':', v) end
---
items:1
bytes_used:160
item_size:64
slabs:1
bytes_free:4194144
...
</programlisting></listitem>
    </varlistentry>
</variablelist>

<variablelist>
    <title>Package <code xml:id="box.stat">box.stat</code></title>
    <para>This package provides access to request
    statistics.</para>
    <varlistentry>
        <term><emphasis role="lua">box.stat</emphasis></term>
        <listitem><bridgehead renderas="sect4">Example</bridgehead><programlisting>
localhost> lua box.stat -- a virtual table
---
 - table: 0x41a07a08
...
localhost> lua box.stat() -- a full table (the same)
---
 - table: 0x41a0ebb0
...
localhost> lua for k, v in pairs(box.stat()) do print(k) end
---
DELETE
SELECT
REPLACE
CALL
UPDATE
DELETE_1_3
...
localhost> lua for k, v in pairs(box.stat().DELETE) do print(k, ': ', v) end
---
total: 23210
rps: 22
...
localhost> lua for k, v in pairs(box.stat.DELETE) do print(k, ': ', v) end -- the same
---
total: 23210
rps: 22
...
localhost> lua for k, v in pairs(box.stat.SELECT) do print(k, ': ', v) end
---
total: 34553330
rps: 23
...
localhost>
</programlisting></listitem>
    </varlistentry>
</variablelist>

<para>
    Additional examples can be found in the open source <link
    xlink:href="https://github.com/mailru/tntlua">Lua stored
    procedures repository</link> and in the server test suite.
</para>
</section>

<section>
<title>Limitation of stored procedures</title>

<para>
    There are two limitations in stored procedures support one should
    be aware of: execution atomicity and lack of typing.
</para>
<bridgehead renderas="sect4">Cooperative multitasking environment</bridgehead>
<para>
    Tarantool core is built around cooperative multi-tasking
    paradigm: unless a running fiber deliberately yields control
    to some other fiber, it is not preempted.
    <quote>Yield points</quote> are built into all
    calls from Tarantool core to the operating system.
    Any system call which can block is performed in
    asynchronous manner and the fiber waiting
    on the system call is preempted with a fiber ready to
    run. This model makes all programmatic locks unnecessary:
    cooperative multitasking ensures that there is no concurrency
    around a resource, no race conditions and no memory
    consistency issues.
</para>
<para>
    When requests are small, e.g. simple UPDATE, INSERT, DELETE,
    SELECT, fiber scheduling is fair: it takes only a little time
    to process the request, schedule a disk write, and yield to
    a fiber serving the next client.
</para>
<para>
    A stored procedure, however, can perform complex computations,
    or be written in such a way that control is not given away for a
    long time. This can lead to unfair scheduling, when a single
    client throttles the rest of the system, or to apparent stalls
    in request processing.
    Avoiding this situation is responsibility of the stored procedure
    author. Most of <code>box</code> calls, such as
    <code>box.insert()</code>, <code>box.update()</code>,
    <code>box.delete()</code> are yield points; <code>box.select()</code>
    and <code>box.select_range()</code>, however, are not.
</para>
<para>
    It should also be noted, that in absence of transactions,
    any yield in a stored procedure is a potential change in the
    database state. Effectively, it's only possible
    to have CAS (compare-and-swap) -like atomic stored
    procedures: i.e. procedures which select and then modify a record.

    Multiple data change requests always run through a built-in
    yield point.
</para>
<bridgehead renderas="sect4">Lack of field types</bridgehead>
<para>
   When invoking a stored procedure from the binary protocol,
   it's not possible to convey types of arguments. Tuples are
   type-agnostic. The conventional workaround is to use
   strings to pass all (textual and numeric) data.
</para>

</section>
</section>

<!--
vim: tw=66 syntax=docbk
vim: spell spelllang=en_us
-->
